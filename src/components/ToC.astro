---
// 可复用目录组件：基于页面中的 `.prose h2-h4` 生成分级目录并高亮当前章节
// 设计目标：
// - 分级嵌套（h2/h3/h4）
// - 平滑滚动至锚点
// - IntersectionObserver 高亮当前可见标题
// - 不与服务端渲染耦合，直接在客户端扫描 DOM
---

<nav id="toc" class="text-sm max-h-[calc(100vh-8rem)] overflow-y-auto overflow-x-hidden overscroll-contain pr-1 w-full">
  <div class="text-gray-600 dark:text-gray-400">
    <p>正在生成目录...</p>
  </div>
</nav>

<script>
  // @ts-nocheck
  /**
   * @typedef {Object} TOCNode
   * @property {string} id
   * @property {string} text
   * @property {number} level
   * @property {TOCNode[]} children
   */

  // 工具：文本转 slug（保留中文，移除空白）
  /** @param {string} text @returns {string} */
  function slugify(text) {
    if (!text) return '';
    const s = text
      .toString()
      .trim()
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[()\[\]{}!?,.;:'"`~*@#$%^&+=<>\\/|]+/g, '')
      .replace(/-+/g, '-')
      .replace(/^-|-$|^_/g, '');
    return s || '';
  }

  /** @param {HTMLElement[]} headings @returns {TOCNode[]} */
  function buildHeadingsTree(headings) {
    /** @type {TOCNode[]} */
    const nodes = [];
    /** @type {{ level: number, children: TOCNode[] }[]} */
    const stack = [{ level: 1, children: nodes }];

    headings.forEach(/** @param {HTMLElement} heading @param {number} index */ (heading, index) => {
      const level = parseInt(heading.tagName.charAt(1));
      const rawText = heading.textContent?.trim() || '';
      // 若已有 id 则复用，否则生成并设置
      let id = heading.id;
      if (!id) {
        const base = slugify(rawText) || `heading-${index}`;
        let unique = base;
        let n = 1;
        // 防止页面内重复 id
        while (document.getElementById(unique)) {
          unique = `${base}-${n++}`;
        }
        id = unique;
        heading.id = id;
      }

      /** @type {TOCNode} */
      const node = { id, text: rawText, level, children: [] };

      // 维护栈以构建树（支持 h2-h4）
      while (stack.length && stack[stack.length - 1].level >= level) {
        stack.pop();
      }
      stack[stack.length - 1].children.push(node);
      stack.push(node);
    });

    return nodes;
  }

  /** @param {TOCNode[]} nodes @returns {string} */
  function renderTree(nodes) {
    if (!nodes || nodes.length === 0) return '<div class="text-gray-600 dark:text-gray-400"><p>暂无目录</p></div>';
    /** @param {TOCNode[]} items @returns {string} */
    const render = (items) => {
      let html = '<ul class="space-y-1 w-full">';
      items.forEach((/** @type {TOCNode} */ n) => {
        const hasChildren = !!(n.children && n.children.length);
        const expanded = n.level < 3; // 默认展开 h2，折叠 h3/h4
        const toggle = hasChildren
          ? `<button type="button" class="mr-1 inline-flex items-center justify-center w-4 h-4 rounded toc-toggle text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors" data-toggle-for="${n.id}" aria-expanded="${expanded ? 'true' : 'false'}" aria-label="切换子级">
               <svg viewBox="0 0 20 20" class="w-3 h-3 transition-transform ${expanded ? 'rotate-90' : ''}">
                 <path fill="currentColor" d="M7 5l6 5-6 5V5z" />
               </svg>
             </button>`
          : `<span class="mr-1 inline-block w-4 h-4"></span>`;

        html += `
          <li>
            <div class="flex items-center">
              ${toggle}
              <a href="#${n.id}" class="flex-1 py-1 px-2 text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 hover:bg-gray-50 dark:hover:bg-gray-700 rounded transition-colors break-words overflow-hidden" data-level="${n.level}">
                ${n.text}
              </a>
            </div>
            ${hasChildren ? `<div class="pl-4 border-l border-gray-200 dark:border-gray-700 mt-1 ${expanded ? '' : 'hidden'}" data-children-for="${n.id}">${render(n.children)}</div>` : ''}
          </li>
        `;
      });
      html += '</ul>';
      return html;
    };
    return `<nav class="space-y-1">${render(nodes)}</nav>`;
  }

  /** 统一处理目录点击事件：折叠/展开 + 平滑滚动 */
  /** @param {HTMLElement} container @param {Object} scrollState */
  function initTocInteraction(container, scrollState) {
    container.addEventListener('click', (e) => {
      const target = e.target;
      if (!(target instanceof Element)) return;
      
      // 处理折叠按钮点击
      const btn = target.closest('button.toc-toggle');
      if (btn) {
        e.preventDefault();
        e.stopPropagation();
        const forId = btn.getAttribute('data-toggle-for');
        if (!forId) return;
        const panel = container.querySelector(`[data-children-for="${forId}"]`);
        const icon = btn.querySelector('svg');
        if (!panel) return;
        const isHidden = panel.classList.contains('hidden');
        if (isHidden) {
          panel.classList.remove('hidden');
          btn.setAttribute('aria-expanded', 'true');
          icon && icon.classList.add('rotate-90');
        } else {
          panel.classList.add('hidden');
          btn.setAttribute('aria-expanded', 'false');
          icon && icon.classList.remove('rotate-90');
        }
        return;
      }
      
      // 处理目录链接点击
      const link = target.closest('a[href^="#"]');
      if (link) {
        const hash = link.getAttribute('href');
        if (!hash) return;
        const el = document.querySelector(hash);
        if (!el) return;
        e.preventDefault();
        
        // 设置标志，防止滚动时触发目录自动滚动
        scrollState.isScrollingToTarget = true;
        setTimeout(() => { scrollState.isScrollingToTarget = false; }, 1000);
        
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        if (history.replaceState) {
          history.replaceState(null, '', hash);
        } else {
          location.hash = hash;
        }
      }
    });
  }

  /** 展开包含指定链接的所有上级面板，确保可见 */
  /** @param {HTMLElement} container @param {HTMLAnchorElement} link */
  function expandAncestors(container, link) {
    let panel = link.closest('[data-children-for]');
    while (panel) {
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        const parentId = panel.getAttribute('data-children-for');
        if (parentId) {
          const btn = container.querySelector(`button.toc-toggle[data-toggle-for="${parentId}"]`);
          const icon = btn && btn.querySelector('svg');
          if (btn) btn.setAttribute('aria-expanded', 'true');
          if (icon) icon.classList.add('rotate-90');
        }
      }
      panel = panel.parentElement ? panel.parentElement.closest('[data-children-for]') : null;
    }
  }

  /** @param {HTMLElement} container @param {HTMLElement[]} headings @param {Object} scrollState */
  function initScrollSpy(container, headings, scrollState) {
    /** @type {HTMLAnchorElement[]} */
    const links = /** @type {HTMLAnchorElement[]} */ (Array.from(container.querySelectorAll('a[href^="#"]')));
    if (headings.length === 0 || links.length === 0) return;

    /** @type {Map<string, HTMLAnchorElement>} */
    const byId = new Map();
    links.forEach((/** @type {HTMLAnchorElement} */ l) => {
      const href = l.getAttribute('href');
      if (href && href.startsWith('#')) {
        byId.set(href.slice(1), l);
      }
    });

    let activeId = '';
    let scrollTimeout = null;
    
    /** @param {string} id */
    const activate = (id) => {
      if (activeId === id) return;
      activeId = id;
      links.forEach((/** @type {HTMLAnchorElement} */ l) => l.classList.remove('text-blue-600', 'dark:text-blue-400', 'bg-blue-50', 'dark:bg-blue-900/20', 'font-medium'));
      const link = byId.get(id);
      if (link) {
        link.classList.add('text-blue-600', 'dark:text-blue-400', 'bg-blue-50', 'dark:bg-blue-900/20', 'font-medium');
        // 展开祖先面板
        expandAncestors(container, link);
        
        // 只在用户不主动滚动时，才自动滚动目录项到可视区域
        if (!scrollState.isScrollingToTarget) {
          if (scrollTimeout) clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            try { 
              link.scrollIntoView({ block: 'nearest', inline: 'nearest', behavior: 'smooth' }); 
            } catch (e) {}
          }, 100);
        }
      }
    };

    const observer = new IntersectionObserver(
      (entries) => {
        // 选择距离顶部最近且可见的标题
        const visible = entries
          .filter((e) => e.isIntersecting)
          .sort((a, b) => (a.boundingClientRect.top - b.boundingClientRect.top));
        if (visible.length > 0) {
          activate((/** @type {HTMLElement} */ (visible[0].target)).id);
        } else {
          // 回退：找已越过顶部的最后一个
          let current = '';
          headings.forEach((/** @type {HTMLElement} */ h) => {
            const rect = h.getBoundingClientRect();
            if (rect.top <= 120) current = h.id;
          });
          if (current) activate(current);
        }
      },
      { rootMargin: '-96px 0px -60% 0px', threshold: [0, 0.25, 0.5, 0.75, 1.0] }
    );

    headings.forEach((/** @type {Element} */ h) => observer.observe(h));
  }

  function initTOC() {
    const toc = document.getElementById('toc');
    if (!toc) return;
    const article = document.querySelector('.prose');
    if (!article) return;
    /** @type {HTMLElement[]} */
    const headings = /** @type {HTMLElement[]} */ (Array.from(article.querySelectorAll('h2, h3, h4')));
    if (headings.length === 0) {
      toc.innerHTML = '<div class="text-gray-600 dark:text-gray-400"><p>暂无目录</p></div>';
      return;
    }
    const tree = buildHeadingsTree(headings);
    toc.innerHTML = renderTree(tree);
    
    // 共享滚动状态，避免点击目录后触发自动滚动
    const scrollState = { isScrollingToTarget: false };
    initTocInteraction(/** @type {HTMLElement} */ (toc), scrollState);
    initScrollSpy(/** @type {HTMLElement} */ (toc), headings, scrollState);
  }

  document.addEventListener('DOMContentLoaded', initTOC);
</script>
