---
// Coze 智能助手聊天组件 - 使用 Coze API 实现完全会话隔离
export interface Props {
  botId?: string;
  title?: string;
  token?: string;
}

const {
  botId = import.meta.env.PUBLIC_COZE_BOT_ID || '7557962207624609842',
  title = import.meta.env.PUBLIC_COZE_TITLE || '智能助手',
  token = import.meta.env.PUBLIC_COZE_TOKEN || ''
} = Astro.props;
---

<!-- 自定义聊天窗口 -->
<div id="coze-chat-container" class="fixed bottom-4 right-4 z-50">
  <!-- 聊天窗口 -->
  <div id="coze-chat-window" class="hidden bg-white dark:bg-gray-800 rounded-lg shadow-2xl w-96 h-[600px] max-h-[80vh] overflow-hidden border border-gray-200 dark:border-gray-700">
    <!-- 头部 -->
    <div class="flex items-center justify-between p-4 bg-gradient-to-r from-primary-500 to-primary-600 text-white">
      <div class="flex items-center space-x-2">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"/>
        </svg>
        <h3 class="font-semibold">{title}</h3>
      </div>
      <div class="flex items-center space-x-2">
        <button id="new-conversation-btn" class="p-1 hover:bg-white/20 rounded transition-colors" title="新对话">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
          </svg>
        </button>
        <button id="close-chat-btn" class="p-1 hover:bg-white/20 rounded transition-colors" title="关闭">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
    </div>

    <!-- 消息列表 -->
    <div id="messages-container" class="flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50 dark:bg-gray-900">
      <!-- 欢迎消息 -->
      <div class="flex items-start space-x-2">
        <div class="flex-shrink-0 w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center text-white">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
          </svg>
        </div>
        <div class="flex-1 bg-white dark:bg-gray-800 rounded-lg p-3 shadow-sm">
          <p class="text-sm text-gray-800 dark:text-gray-200">你好！我是 AI 助手，有什么可以帮你的吗？</p>
        </div>
      </div>
    </div>

    <!-- 输入区域 -->
    <div class="p-4 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
      <div class="flex items-end space-x-2">
        <textarea
          id="message-input"
          rows="1"
          placeholder="输入消息..."
          class="flex-1 resize-none rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 px-4 py-2 text-sm text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
        ></textarea>
        <button
          id="send-btn"
          class="flex-shrink-0 bg-primary-500 hover:bg-primary-600 text-white rounded-lg p-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          title="发送"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
          </svg>
        </button>
      </div>
    </div>

    <!-- 加载指示器 -->
    <div id="loading-indicator" class="hidden absolute inset-0 bg-black/10 backdrop-blur-sm flex items-center justify-center">
      <div class="bg-white dark:bg-gray-800 rounded-lg p-4 shadow-lg">
        <div class="flex items-center space-x-3">
          <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-primary-500"></div>
          <span class="text-sm text-gray-700 dark:text-gray-300">AI 正在思考...</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ botId, title, token }}>
  console.log('CozeChat 自定义组件初始化...');
  console.log('Bot ID:', botId);
  console.log('Token:', token ? '已设置' : '未设置');
  
  class CozeChatClient {
    constructor() {
      this.botId = botId;
      this.token = token;
      this.conversationId = null;
      this.userId = null;
      this.messages = [];
      
      // DOM 元素
      this.container = document.getElementById('coze-chat-container');
      this.chatWindow = document.getElementById('coze-chat-window');
      this.messagesContainer = document.getElementById('messages-container');
      this.messageInput = document.getElementById('message-input');
      this.sendBtn = document.getElementById('send-btn');
      this.closeBtn = document.getElementById('close-chat-btn');
      this.newConversationBtn = document.getElementById('new-conversation-btn');
      this.loadingIndicator = document.getElementById('loading-indicator');
      
      this.init();
    }

    init() {
      console.log('初始化 CozeChat，Token 状态:', this.token ? '已设置' : '未设置');
      console.log('Token 值:', this.token);
      
      if (!this.token) {
        console.warn('Coze: 请配置 PUBLIC_COZE_TOKEN');
        this.addMessage('error', '请配置 Coze Token 才能使用 AI 助手功能');
      return;
    }
    
      // 创建新会话
      this.createNewConversation();
      
      // 绑定事件
      this.bindEvents();
      
      console.log('CozeChat 自定义组件初始化完成');
    }

    createNewConversation() {
      // 生成全新的 conversation_id 和 user_id
      const timestamp = Date.now();
      const random1 = Math.random().toString(36).substring(2, 15);
      const random2 = Math.random().toString(36).substring(2, 15);
      
      this.conversationId = `conv_${timestamp}_${random1}`;
      this.userId = `user_${timestamp}_${random2}`;
      this.messages = [];
      
      console.log('创建新会话:', {
        conversationId: this.conversationId,
        userId: this.userId
      });
      
      // 清空消息列表，只保留欢迎消息
      this.clearMessages();
    }

    clearMessages() {
      this.messagesContainer.innerHTML = `
        <div class="flex items-start space-x-2">
          <div class="flex-shrink-0 w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
            </svg>
          </div>
          <div class="flex-1 bg-white dark:bg-gray-800 rounded-lg p-3 shadow-sm">
            <p class="text-sm text-gray-800 dark:text-gray-200">你好！我是 AI 助手，有什么可以帮你的吗？</p>
          </div>
        </div>
      `;
    }

    bindEvents() {
      // 打开聊天按钮（由 Layout.astro 触发）
      document.addEventListener('click', (e) => {
        if (e.target.closest('[data-chat-trigger]')) {
          this.openChat();
        }
      });

      // 关闭聊天
      this.closeBtn.addEventListener('click', () => {
        this.closeChat();
      });

      // 新对话
      this.newConversationBtn.addEventListener('click', () => {
        this.createNewConversation();
      });

      // 发送消息
      this.sendBtn.addEventListener('click', () => {
        this.handleSendMessage();
      });

      // 回车发送
      this.messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSendMessage();
        }
      });

      // 自动调整输入框高度
      this.messageInput.addEventListener('input', () => {
        this.messageInput.style.height = 'auto';
        this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 120) + 'px';
      });
    }

    openChat() {
      this.chatWindow.classList.remove('hidden');
      this.chatWindow.style.display = 'flex';
      this.chatWindow.style.flexDirection = 'column';
      this.messageInput.focus();
    }

    closeChat() {
      this.chatWindow.classList.add('hidden');
      this.chatWindow.style.display = 'none';
    }

    async handleSendMessage() {
      const message = this.messageInput.value.trim();
      
      if (!message) return;
      
      // 禁用输入
      this.setInputEnabled(false);
      
      // 添加用户消息到界面
      this.addMessage('user', message);
      
      // 清空输入框
      this.messageInput.value = '';
      this.messageInput.style.height = 'auto';
      
      // 显示加载状态
      this.showLoading(true);
      
      try {
        // 调用 Coze API
        const response = await this.sendMessageToCoze(message);
        console.log('API 响应:', response);
        
        // 处理响应
        if (response.code === 0 && response.data) {
          const assistantMessage = this.extractMessageFromResponse(response.data);
          console.log('提取的消息:', assistantMessage);
          this.addMessage('assistant', assistantMessage);
        } else {
          console.error('API 返回错误:', response);
          throw new Error(response.msg || '发送失败');
        }
      } catch (error) {
        console.error('发送消息失败:', error);
        console.error('错误详情:', {
          message: error.message,
          stack: error.stack,
          name: error.name
        });
        this.addMessage('error', `抱歉，发送消息失败：${error.message}`);
      } finally {
        this.showLoading(false);
        this.setInputEnabled(true);
        this.messageInput.focus();
      }
    }

    async sendMessageToCoze(message) {
      console.log('发送消息到 Coze API:', {
        botId: this.botId,
        userId: this.userId,
        conversationId: this.conversationId,
        message: message
      });
      
      // 先尝试流式请求（根据你的数据，流式请求有完整响应）
      try {
        return await this.sendStreamRequest(message);
      } catch (error) {
        console.log('流式请求失败，尝试非流式请求:', error);
        return await this.sendNonStreamRequest(message);
      }
    }

    async sendStreamRequest(message) {
      const response = await fetch('https://api.coze.cn/v3/chat', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          bot_id: this.botId,
          user_id: this.userId,
          conversation_id: this.conversationId,
          stream: true,
          auto_save_history: false,
          additional_messages: [
            {
              role: 'user',
              content: message,
              content_type: 'text'
            }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      // 处理流式响应
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let fullResponse = '';
      let lastMessage = '';
      let followUpMessages = [];
      
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          const chunk = decoder.decode(value, { stream: true });
          console.log('收到流式数据块:', chunk);
          
          const lines = chunk.split('\n');
          
          let currentEvent = null;
          let currentData = null;
          
          for (const line of lines) {
            // 处理 event: 开头的行
            if (line.startsWith('event:')) {
              currentEvent = line.slice(6).trim();
              console.log('收到事件:', currentEvent);
            }
            // 处理 data: 开头的行
            else if (line.startsWith('data:')) {
              const data = line.slice(5).trim();
              if (data === '[DONE]' || data === '') continue;
              
              currentData = data;
              console.log('准备解析数据:', data);
              
              try {
                const parsed = JSON.parse(data);
                console.log('解析的流式数据:', parsed);
                
                // 如果有事件信息，添加到解析结果中
                if (currentEvent) {
                  parsed.event = currentEvent;
                }
                
                // 处理增量消息（优先处理，这是主要的答案内容）
                if (parsed.event === 'conversation.message.delta' && parsed.data?.content) {
                  console.log('收到增量消息:', parsed.data.content);
                  fullResponse += parsed.data.content;
                  lastMessage = fullResponse; // 更新最后消息
                }
                // 处理不同类型的响应事件
                else if (parsed.event === 'conversation.message.completed' && parsed.data) {
                  const messageData = parsed.data;
                  console.log('处理完成消息:', messageData.type, messageData.content);
                  
                  // 处理主要答案消息（优先显示）
                  if (messageData.type === 'answer' && messageData.content) {
                    console.log('设置答案消息:', messageData.content);
                    lastMessage = messageData.content;
                    fullResponse = messageData.content;
                  }
                  // 处理详细响应（包含工具输出内容）
                  else if (messageData.type === 'verbose' && messageData.content) {
                    const verboseContent = this.parseVerboseContent(messageData.content);
                    if (verboseContent) {
                      console.log('设置详细响应:', verboseContent);
                      lastMessage = verboseContent;
                      fullResponse = verboseContent;
                    }
                  }
                  // 处理 follow_up 类型的消息（建议问题）
                  else if (messageData.type === 'follow_up' && messageData.content) {
                    console.log('添加建议问题:', messageData.content);
                    followUpMessages.push(messageData.content);
                  }
                  // 跳过其他类型的消息（function_call, tool_response 等）
                  else if (messageData.type === 'function_call' || messageData.type === 'tool_response') {
                    console.log('跳过消息类型:', messageData.type);
                  }
                  // 处理其他类型的消息
                  else if (messageData.content && typeof messageData.content === 'string') {
                    // 尝试解析 JSON 格式的 content
                    const parsedContent = this.parseMessageContent(messageData.content);
                    if (parsedContent) {
                      console.log('设置解析内容:', parsedContent);
                      lastMessage = parsedContent;
                      fullResponse = parsedContent;
                    } else {
                      console.log('设置原始内容:', messageData.content);
                      lastMessage = messageData.content;
                      fullResponse = messageData.content;
                    }
                  }
                }
                // 处理其他格式（但要过滤掉技术信息）
                else if (parsed.data?.content) {
                  // 检查是否是技术信息，如果是则跳过
                  if (!this.isTechnicalContent(parsed.data.content)) {
                    fullResponse += parsed.data.content;
                  }
                } else if (parsed.content) {
                  // 检查是否是技术信息，如果是则跳过
                  if (!this.isTechnicalContent(parsed.content)) {
                    fullResponse += parsed.content;
                  }
                } else if (parsed.message?.content) {
                  // 检查是否是技术信息，如果是则跳过
                  if (!this.isTechnicalContent(parsed.message.content)) {
                    fullResponse += parsed.message.content;
                  }
                }
              } catch (e) {
                console.log('解析流式数据失败:', e, '原始数据:', currentData);
                console.log('数据长度:', currentData.length);
                console.log('数据类型:', typeof currentData);
              }
              
              // 重置事件和数据
              currentEvent = null;
              currentData = null;
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
      
      // 使用最后的消息或累积的响应
      const finalResponse = lastMessage || fullResponse;
      console.log('Coze API 响应完成:');
      console.log('- lastMessage:', lastMessage);
      console.log('- fullResponse:', fullResponse);
      console.log('- finalResponse:', finalResponse);
      console.log('- followUpMessages:', followUpMessages);
      
      // 构建最终回复内容
      let responseContent = '';
      
      // 如果有主要回复内容，使用它
      if (finalResponse && finalResponse.trim() !== '') {
        // 清理主要回复内容
        responseContent = this.cleanContent(finalResponse.trim());
        
        // 如果有建议问题，添加到回复后面
        if (followUpMessages.length > 0) {
          responseContent += '\n\n**建议问题：**\n';
          followUpMessages.forEach((question, index) => {
            responseContent += `${index + 1}. ${question}\n`;
          });
        }
      }
      // 如果没有主要回复，但有建议问题，使用建议问题
      else if (followUpMessages.length > 0) {
        console.log('使用建议问题作为回复');
        responseContent = '**建议问题：**\n';
        followUpMessages.forEach((question, index) => {
          responseContent += `${index + 1}. ${question}\n`;
        });
      }
      // 如果都没有，返回默认消息
      else {
        console.log('未收到有效响应，返回默认消息');
        responseContent = '抱歉，我无法回答这个问题。请尝试其他问题。';
      }
      
      return { code: 0, data: { content: responseContent } };
    }

    async sendNonStreamRequest(message) {
      console.log('发送非流式请求...');
      
      const requestBody = {
        bot_id: this.botId,
        user_id: this.userId,
        conversation_id: this.conversationId,
        stream: false,
        auto_save_history: false,
        additional_messages: [
          {
            role: 'user',
            content: message,
            content_type: 'text'
          }
        ]
      };
      
      console.log('请求体:', requestBody);
      
      const response = await fetch('https://api.coze.cn/v3/chat', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      console.log('响应状态:', response.status, response.statusText);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('HTTP 错误响应:', errorText);
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
      }

      const data = await response.json();
      console.log('非流式响应:', data);
      
      if (data.code === 0 && data.data) {
        // 处理非流式响应的消息提取
        let messageContent = '';
        if (data.data.messages && data.data.messages.length > 0) {
          const assistantMessages = data.data.messages.filter(msg => msg.role === 'assistant');
          if (assistantMessages.length > 0) {
            messageContent = assistantMessages[assistantMessages.length - 1].content;
          }
        }
        
        return { 
          code: 0, 
          data: { 
            content: messageContent || '收到回复，但无法提取内容。' 
          } 
        };
      } else {
        console.error('API 返回错误码:', data);
        throw new Error(data.msg || `请求失败，错误码: ${data.code}`);
      }
    }

    parseToolContent(content) {
      try {
        const parsed = JSON.parse(content);
        console.log('解析工具内容:', parsed);
        
        // 处理 stream_plugin_finish 类型
        if (parsed.msg_type === 'stream_plugin_finish' && parsed.data) {
          const dataParsed = JSON.parse(parsed.data);
          if (dataParsed.tool_output_content) {
            return dataParsed.tool_output_content;
          }
        }
        
        // 处理其他工具响应格式
        if (parsed.tool_output_content) {
          return parsed.tool_output_content;
        }
        
        return null;
      } catch (e) {
        console.log('解析工具内容失败:', e);
        return null;
      }
    }

    parseVerboseContent(content) {
      try {
        const parsed = JSON.parse(content);
        console.log('解析详细内容:', parsed);
        
        // 处理 stream_plugin_finish 类型
        if (parsed.msg_type === 'stream_plugin_finish' && parsed.data) {
          const dataParsed = JSON.parse(parsed.data);
          console.log('解析 stream_plugin_finish 数据:', dataParsed);
          if (dataParsed.tool_output_content) {
            console.log('提取工具输出内容:', dataParsed.tool_output_content);
            return dataParsed.tool_output_content;
          }
        }
        
        // 处理 generate_answer_finish 类型
        if (parsed.msg_type === 'generate_answer_finish') {
          // 这种类型通常表示生成完成，但没有具体内容
          console.log('generate_answer_finish - 无内容');
          return null;
        }
        
        // 处理 empty result 类型
        if (parsed.msg_type === 'empty result') {
          console.log('empty result - 返回默认消息');
          return '抱歉，我无法回答这个问题。';
        }
        
        console.log('未匹配的详细内容类型:', parsed.msg_type);
        return null;
      } catch (e) {
        console.log('解析详细内容失败:', e);
        return null;
      }
    }

    parseMessageContent(content) {
      try {
        const parsed = JSON.parse(content);
        console.log('解析消息内容:', parsed);
        
        // 处理不同的消息类型
        if (parsed.msg_type === 'stream_plugin_finish' && parsed.data) {
          const dataParsed = JSON.parse(parsed.data);
          if (dataParsed.tool_output_content) {
            return dataParsed.tool_output_content;
          }
        }
        
        if (parsed.msg_type === 'generate_answer_finish') {
          // 这种类型通常表示生成完成，但没有具体内容
          return null;
        }
        
        if (parsed.msg_type === 'empty result') {
          return '抱歉，我无法回答这个问题。';
        }
        
        return null;
      } catch (e) {
        console.log('解析消息内容失败:', e);
        return null;
      }
    }

    extractMessageFromResponse(data) {
      console.log('提取消息，响应数据:', data);
      
      // 从流式响应中提取助手的消息
      if (data.content) {
        return data.content;
      }
      
      // 从非流式响应中提取消息
      if (data.messages && data.messages.length > 0) {
        const assistantMessages = data.messages.filter(msg => msg.role === 'assistant');
        if (assistantMessages.length > 0) {
          return assistantMessages[assistantMessages.length - 1].content;
        }
      }
      
      // 尝试其他可能的字段
      if (data.message?.content) {
        return data.message.content;
      }
      
      if (data.text) {
        return data.text;
      }
      
      console.error('无法提取消息内容，完整响应:', data);
      return '收到回复，但格式异常。';
    }

    addMessage(role, content) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'flex items-start space-x-2';
      
      if (role === 'user') {
        messageDiv.classList.add('flex-row-reverse', 'space-x-reverse');
        messageDiv.innerHTML = `
          <div class="flex-shrink-0 w-8 h-8 bg-gray-400 dark:bg-gray-600 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
            </svg>
          </div>
          <div class="flex-1 bg-primary-500 text-white rounded-lg p-3 shadow-sm">
            <p class="text-sm whitespace-pre-wrap">${this.escapeHtml(content)}</p>
          </div>
        `;
      } else if (role === 'assistant') {
        messageDiv.innerHTML = `
          <div class="flex-shrink-0 w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
            </svg>
          </div>
          <div class="flex-1 bg-white dark:bg-gray-800 rounded-lg p-3 shadow-sm">
            <div class="text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${this.formatMessage(content)}</div>
          </div>
        `;
      } else if (role === 'error') {
        messageDiv.innerHTML = `
          <div class="flex-shrink-0 w-8 h-8 bg-red-500 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
          <div class="flex-1 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3">
            <p class="text-sm text-red-800 dark:text-red-200">${this.escapeHtml(content)}</p>
          </div>
        `;
      }
      
      this.messagesContainer.appendChild(messageDiv);
      
      // 滚动到底部
      this.scrollToBottom();
    }

    isTechnicalContent(content) {
      // 检查是否是技术信息
      if (typeof content !== 'string') return false;
      
      // 检查是否包含 JSON 格式的技术信息
      if (content.includes('{"name":') || 
          content.includes('"plugin_id":') ||
          content.includes('"msg_type":') ||
          content.includes('"uuid":') ||
          content.includes('"finish_reason":') ||
          content.includes('bolg_protagonisths_wf directly streaming reply')) {
        return true;
      }
      
      return false;
    }

    formatMessage(content) {
      // 清理内容，移除技术信息
      let cleanedContent = this.cleanContent(content);
      
      // 简单的 Markdown 格式化
      let formatted = this.escapeHtml(cleanedContent);
      
      // 处理粗体 **text**
      formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      
      // 处理换行
      formatted = formatted.replace(/\n/g, '<br>');
      
      return formatted;
    }

    cleanContent(content) {
      if (typeof content !== 'string') return content;
      
      // 移除 JSON 格式的技术信息
      let cleaned = content
        // 移除完整的 JSON 对象
        .replace(/\{[^}]*"name":"[^"]*"[^}]*\}/g, '')
        .replace(/\{[^}]*"plugin_id":[^}]*\}/g, '')
        .replace(/\{[^}]*"msg_type":"[^"]*"[^}]*\}/g, '')
        .replace(/\{[^}]*"uuid":"[^"]*"[^}]*\}/g, '')
        .replace(/\{[^}]*"finish_reason":[^}]*\}/g, '')
        // 移除技术提示信息
        .replace(/bolg_protagonisths_wf directly streaming reply\./g, '')
        // 清理多余的空格和换行
        .replace(/\s+/g, ' ')
        .trim();
      
      return cleaned;
    }

    scrollToBottom() {
      setTimeout(() => {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      }, 100);
    }

    showLoading(show) {
      if (show) {
        this.loadingIndicator.classList.remove('hidden');
      } else {
        this.loadingIndicator.classList.add('hidden');
      }
    }

    setInputEnabled(enabled) {
      this.messageInput.disabled = !enabled;
      this.sendBtn.disabled = !enabled;
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  }

  // 页面加载完成后初始化
  document.addEventListener('DOMContentLoaded', () => {
    window.cozeChatClient = new CozeChatClient();
  });
</script>

<style>
  /* 自定义滚动条 */
  #messages-container::-webkit-scrollbar {
    width: 6px;
  }

  #messages-container::-webkit-scrollbar-track {
    background: transparent;
  }

  #messages-container::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
  }

  #messages-container::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.3);
  }

  /* 深色模式滚动条 */
  .dark #messages-container::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
  }

  .dark #messages-container::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }

  /* 响应式设计 */
  @media (max-width: 640px) {
    #coze-chat-window {
      width: calc(100vw - 2rem);
      height: calc(100vh - 2rem);
      max-height: calc(100vh - 2rem);
    }
  }
</style>
