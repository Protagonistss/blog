---
// Coze 智能助手聊天组件 - 使用 Coze API 实现完全会话隔离
export interface Props {
  botId?: string;
  title?: string;
  token?: string;
}

const {
  botId = import.meta.env.PUBLIC_COZE_BOT_ID || '7557962207624609842',
  title = import.meta.env.PUBLIC_COZE_TITLE || '智能助手',
  token = import.meta.env.PUBLIC_COZE_TOKEN || ''
} = Astro.props;
---

<!-- 浮动聊天小球 -->
<div id="coze-chat-container" class="fixed bottom-6 right-6 z-50">
  <!-- 聊天小球按钮 -->
  <div id="coze-chat-bubble" class="w-14 h-14 bg-primary-500 hover:bg-primary-600 rounded-full shadow-lg hover:shadow-xl transition-all duration-300 cursor-pointer flex items-center justify-center group">
    <svg class="w-6 h-6 text-white group-hover:scale-110 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
    </svg>
    <!-- 新消息提示点 -->
    <div id="new-message-indicator" class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full hidden">
      <div class="w-full h-full bg-red-500 rounded-full animate-pulse"></div>
    </div>
  </div>

  <!-- 聊天窗口 -->
  <div id="coze-chat-window" class="hidden absolute bottom-16 right-0 bg-white dark:bg-gray-800 rounded-lg shadow-2xl w-96 h-[600px] max-h-[80vh] overflow-hidden border border-gray-200 dark:border-gray-700">
    <!-- 头部 -->
    <div class="flex items-center justify-between p-4 bg-gradient-to-r from-primary-500 to-primary-600 text-white">
      <div class="flex items-center space-x-2">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"/>
        </svg>
        <h3 class="font-semibold">{title}</h3>
      </div>
      <div class="flex items-center space-x-2">
        <button id="new-conversation-btn" class="p-1 hover:bg-white/20 rounded transition-colors" title="新对话">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
          </svg>
        </button>
        <button id="close-chat-btn" class="p-1 hover:bg-white/20 rounded transition-colors" title="关闭">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
    </div>

    <!-- 消息列表 -->
    <div id="messages-container" class="flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50 dark:bg-gray-900">
      <!-- 欢迎消息 -->
      <div class="flex items-start space-x-2">
        <div class="flex-shrink-0 w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center text-white">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
          </svg>
        </div>
        <div class="flex-1 bg-white dark:bg-gray-800 rounded-lg p-3 shadow-sm">
          <p class="text-sm text-gray-800 dark:text-gray-200">你好！我是 AI 助手，有什么可以帮你的吗？</p>
        </div>
      </div>
    </div>

    <!-- 输入区域 -->
    <div class="p-4 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
      <div class="flex items-end space-x-2">
        <textarea
          id="message-input"
          rows="1"
          placeholder="输入消息..."
          class="flex-1 resize-none rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 px-4 py-2 text-sm text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
        ></textarea>
        <button
          id="send-btn"
          class="flex-shrink-0 bg-primary-500 hover:bg-primary-600 text-white rounded-lg p-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          title="发送"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
          </svg>
        </button>
      </div>
    </div>

  </div>
</div>

<script define:vars={{ botId, title, token }}>
  console.log('CozeChat 自定义组件初始化...');
  console.log('Bot ID:', botId);
  console.log('Token:', token ? '已设置' : '未设置');
  
  class CozeChatClient {
    constructor() {
      this.botId = botId;
      this.token = token;
      this.conversationId = null;
      this.userId = null;
      this.messages = [];
      
      // DOM 元素
      this.container = document.getElementById('coze-chat-container');
      this.chatBubble = document.getElementById('coze-chat-bubble');
      this.chatWindow = document.getElementById('coze-chat-window');
      this.messagesContainer = document.getElementById('messages-container');
      this.messageInput = document.getElementById('message-input');
      this.sendBtn = document.getElementById('send-btn');
      this.closeBtn = document.getElementById('close-chat-btn');
      this.newConversationBtn = document.getElementById('new-conversation-btn');
      this.newMessageIndicator = document.getElementById('new-message-indicator');
      
      this.init();
    }

    init() {
      console.log('初始化 CozeChat，Token 状态:', this.token ? '已设置' : '未设置');
      
      if (!this.token) {
        console.warn('Coze: 请配置 PUBLIC_COZE_TOKEN');
        this.addMessage('error', '请配置 Coze Token 才能使用 AI 助手功能');
      return;
    }
    
      // 创建新会话
      this.createNewConversation();
      
      // 绑定事件
      this.bindEvents();
      
      console.log('CozeChat 自定义组件初始化完成');
    }

    createNewConversation() {
      // 生成全新的 conversation_id 和 user_id
      const timestamp = Date.now();
      const random1 = Math.random().toString(36).substring(2, 15);
      const random2 = Math.random().toString(36).substring(2, 15);
      
      this.conversationId = `conv_${timestamp}_${random1}`;
      this.userId = `user_${timestamp}_${random2}`;
      this.messages = [];
      
      console.log('创建新会话');
      
      // 清空消息列表，只保留欢迎消息
      this.clearMessages();
    }

    clearMessages() {
      this.messagesContainer.innerHTML = `
        <div class="flex items-start space-x-2">
          <div class="flex-shrink-0 w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
            </svg>
          </div>
          <div class="flex-1 bg-white dark:bg-gray-800 rounded-lg p-3 shadow-sm">
            <p class="text-sm text-gray-800 dark:text-gray-200">你好！我是 AI 助手，有什么可以帮你的吗？</p>
          </div>
        </div>
      `;
    }

    bindEvents() {
      // 浮动小球点击事件
      this.chatBubble.addEventListener('click', () => {
        this.toggleChat();
      });


      // 关闭聊天
      this.closeBtn.addEventListener('click', () => {
        this.closeChat();
      });

      // 新对话
      this.newConversationBtn.addEventListener('click', () => {
        this.createNewConversation();
      });

      // 发送消息
      this.sendBtn.addEventListener('click', () => {
        this.handleSendMessage();
      });

      // 回车发送
      this.messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSendMessage();
        }
      });

      // 自动调整输入框高度
      this.messageInput.addEventListener('input', () => {
        this.messageInput.style.height = 'auto';
        this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 120) + 'px';
      });

      // 点击外部关闭聊天窗口
      document.addEventListener('click', (e) => {
        if (this.chatWindow.classList.contains('flex') && 
            !this.chatWindow.contains(e.target) && 
            !this.chatBubble.contains(e.target)) {
          this.closeChat();
        }
      });
    }

    toggleChat() {
      if (this.chatWindow.classList.contains('hidden')) {
        this.openChat();
      } else {
        this.closeChat();
      }
    }

    openChat() {
      this.chatWindow.classList.remove('hidden');
      this.chatWindow.style.display = 'flex';
      this.chatWindow.style.flexDirection = 'column';
      this.messageInput.focus();
      // 隐藏新消息提示
      this.hideNewMessageIndicator();
    }

    closeChat() {
      this.chatWindow.classList.add('hidden');
      this.chatWindow.style.display = 'none';
    }

    showNewMessageIndicator() {
      if (this.newMessageIndicator) {
        this.newMessageIndicator.classList.remove('hidden');
      }
    }

    hideNewMessageIndicator() {
      if (this.newMessageIndicator) {
        this.newMessageIndicator.classList.add('hidden');
      }
    }

    async handleSendMessage() {
      const message = this.messageInput.value.trim();
      
      if (!message) return;
      
      // 禁用输入
      this.setInputEnabled(false);
      
      // 添加用户消息到界面
      this.addMessage('user', message);
      
      // 清空输入框
      this.messageInput.value = '';
      this.messageInput.style.height = 'auto';
      
      // 添加一个临时的助手消息占位符，用于流式显示
      const tempMessageId = 'temp-' + Date.now();
      this.addTempMessage(tempMessageId);
      
      try {
        // 调用 Coze API
        const response = await this.sendMessageToCoze(message, tempMessageId);
        
        // 处理响应
        if (response.code === 0 && response.data) {
          const assistantMessage = this.extractMessageFromResponse(response.data);
          this.typewriterEffect(tempMessageId, assistantMessage);
        } else {
          throw new Error(response.msg || '发送失败');
        }
      } catch (error) {
        console.error('发送消息失败:', error.message);
        this.updateTempMessage(tempMessageId, `抱歉，发送消息失败：${error.message}`, 'error');
      } finally {
        this.setInputEnabled(true);
        this.messageInput.focus();
      }
    }

    async sendMessageToCoze(message, tempMessageId) {
      console.log('发送消息到 Coze API');
      
      // 先尝试流式请求（根据你的数据，流式请求有完整响应）
      try {
        return await this.sendStreamRequest(message, tempMessageId);
      } catch (error) {
        console.log('流式请求失败，尝试非流式请求');
        return await this.sendNonStreamRequest(message, tempMessageId);
      }
    }

    async sendStreamRequest(message, tempMessageId) {
      const response = await fetch('https://api.coze.cn/v3/chat', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          bot_id: this.botId,
          user_id: this.userId,
          conversation_id: this.conversationId,
          stream: true,
          auto_save_history: false,
          additional_messages: [
            {
              role: 'user',
              content: message,
              content_type: 'text'
            }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      // 处理流式响应
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let fullResponse = '';
      let lastMessage = '';
      let followUpMessages = [];
      let currentContent = '';
      
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          const chunk = decoder.decode(value, { stream: true });
          
          const lines = chunk.split('\n');
          
          let currentEvent = null;
          let currentData = null;
          
          for (const line of lines) {
            // 处理 event: 开头的行
            if (line.startsWith('event:')) {
              currentEvent = line.slice(6).trim();
            }
            // 处理 data: 开头的行
            else if (line.startsWith('data:')) {
              const data = line.slice(5).trim();
              if (data === '[DONE]' || data === '') continue;
              
              currentData = data;
              
              try {
                const parsed = JSON.parse(data);
                
                // 如果有事件信息，添加到解析结果中
                if (currentEvent) {
                  parsed.event = currentEvent;
                }
                
                // 调试：记录事件类型和数据
                console.log('收到事件:', parsed.event, '类型:', parsed.data?.type);
                
                // 处理增量消息（优先处理，这是主要的答案内容）
                if (parsed.event === 'conversation.message.delta' && parsed.data?.content) {
                  fullResponse += parsed.data.content;
                  lastMessage = fullResponse; // 更新最后消息
                  currentContent = fullResponse;
                  
                  // 实时更新显示内容
                  this.updateTempMessageContent(tempMessageId, currentContent);
                }
                // 处理不同类型的响应事件
                else if (parsed.event === 'conversation.message.completed' && parsed.data) {
                  const messageData = parsed.data;
                  
                  // 处理主要答案消息（优先显示）
                  if (messageData.type === 'answer' && messageData.content) {
                    lastMessage = messageData.content;
                    fullResponse = messageData.content;
                    currentContent = messageData.content;
                    
                    // 模拟逐步显示效果
                    this.typewriterEffect(tempMessageId, messageData.content);
                  }
                  // 处理详细响应（包含工具输出内容）
                  else if (messageData.type === 'verbose' && messageData.content) {
                    const verboseContent = this.parseVerboseContent(messageData.content);
                    if (verboseContent) {
                      lastMessage = verboseContent;
                      fullResponse = verboseContent;
                      currentContent = verboseContent;
                      
                      // 模拟逐步显示效果
                      this.typewriterEffect(tempMessageId, verboseContent);
                    }
                  }
                  // 处理 follow_up 类型的消息（建议问题）
                  else if (messageData.type === 'follow_up' && messageData.content) {
                    followUpMessages.push(messageData.content);
                  }
                  // 跳过其他类型的消息（function_call, tool_response 等）
                  else if (messageData.type === 'function_call' || messageData.type === 'tool_response') {
                    // 跳过技术消息
                  }
                  // 处理其他类型的消息
                  else if (messageData.content && typeof messageData.content === 'string') {
                    // 尝试解析 JSON 格式的 content
                    const parsedContent = this.parseMessageContent(messageData.content);
                    if (parsedContent) {
                      lastMessage = parsedContent;
                      fullResponse = parsedContent;
                      currentContent = parsedContent;
                      
                      // 实时更新显示内容
                      this.updateTempMessageContent(tempMessageId, currentContent);
                    } else {
                      lastMessage = messageData.content;
                      fullResponse = messageData.content;
                      currentContent = messageData.content;
                      
                      // 实时更新显示内容
                      this.updateTempMessageContent(tempMessageId, currentContent);
                    }
                  }
                }
                // 处理其他格式（但要过滤掉技术信息）
                else if (parsed.data?.content) {
                  // 检查是否是技术信息，如果是则跳过
                  if (!this.isTechnicalContent(parsed.data.content)) {
                    fullResponse += parsed.data.content;
                  }
                } else if (parsed.content) {
                  // 检查是否是技术信息，如果是则跳过
                  if (!this.isTechnicalContent(parsed.content)) {
                    fullResponse += parsed.content;
                  }
                } else if (parsed.message?.content) {
                  // 检查是否是技术信息，如果是则跳过
                  if (!this.isTechnicalContent(parsed.message.content)) {
                    fullResponse += parsed.message.content;
                  }
                }
              } catch (e) {
                console.log('解析流式数据失败');
              }
              
              // 重置事件和数据
              currentEvent = null;
              currentData = null;
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
      
      // 使用最后的消息或累积的响应
      const finalResponse = lastMessage || fullResponse;
      console.log('Coze API 响应完成');
      
      // 构建最终回复内容
      let responseContent = '';
      
      // 如果有主要回复内容，使用它
      if (finalResponse && finalResponse.trim() !== '') {
        // 清理主要回复内容
        responseContent = this.cleanContent(finalResponse.trim());
        
        // 如果有建议问题，添加到回复后面
        if (followUpMessages.length > 0) {
          responseContent += '\n\n**建议问题：**\n';
          followUpMessages.forEach((question, index) => {
            responseContent += `${index + 1}. ${question}\n`;
          });
          
          // 使用打字机效果显示最终内容（包含建议问题）
          this.typewriterEffect(tempMessageId, responseContent);
        }
      }
      // 如果没有主要回复，但有建议问题，使用建议问题
      else if (followUpMessages.length > 0) {
        responseContent = '**建议问题：**\n';
        followUpMessages.forEach((question, index) => {
          responseContent += `${index + 1}. ${question}\n`;
        });
        
        // 使用打字机效果显示最终内容
        this.typewriterEffect(tempMessageId, responseContent);
      }
      // 如果都没有，返回默认消息
      else {
        responseContent = '抱歉，我无法回答这个问题。请尝试其他问题。';
        this.typewriterEffect(tempMessageId, responseContent);
      }
      
      return { code: 0, data: { content: responseContent } };
    }

    async sendNonStreamRequest(message, tempMessageId) {
      console.log('发送非流式请求...');
      
      const requestBody = {
        bot_id: this.botId,
        user_id: this.userId,
        conversation_id: this.conversationId,
        stream: false,
        auto_save_history: false,
        additional_messages: [
          {
            role: 'user',
            content: message,
            content_type: 'text'
          }
        ]
      };
      
      console.log('发送非流式请求');
      
      const response = await fetch('https://api.coze.cn/v3/chat', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      console.log('响应状态:', response.status, response.statusText);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.code === 0 && data.data) {
        // 处理非流式响应的消息提取
        let messageContent = '';
        if (data.data.messages && data.data.messages.length > 0) {
          const assistantMessages = data.data.messages.filter(msg => msg.role === 'assistant');
          if (assistantMessages.length > 0) {
            messageContent = assistantMessages[assistantMessages.length - 1].content;
          }
        }
        
        return { 
          code: 0, 
          data: { 
            content: messageContent || '收到回复，但无法提取内容。' 
          } 
        };
      } else {
        throw new Error(data.msg || `请求失败，错误码: ${data.code}`);
      }
    }

    parseToolContent(content) {
      try {
        const parsed = JSON.parse(content);
        
        // 处理 stream_plugin_finish 类型
        if (parsed.msg_type === 'stream_plugin_finish' && parsed.data) {
          const dataParsed = JSON.parse(parsed.data);
          if (dataParsed.tool_output_content) {
            return dataParsed.tool_output_content;
          }
        }
        
        // 处理其他工具响应格式
        if (parsed.tool_output_content) {
          return parsed.tool_output_content;
        }
        
        return null;
      } catch (e) {
        return null;
      }
    }

    parseVerboseContent(content) {
      try {
        const parsed = JSON.parse(content);
        
        // 处理 stream_plugin_finish 类型
        if (parsed.msg_type === 'stream_plugin_finish' && parsed.data) {
          const dataParsed = JSON.parse(parsed.data);
          if (dataParsed.tool_output_content) {
            return dataParsed.tool_output_content;
          }
        }
        
        // 处理 generate_answer_finish 类型
        if (parsed.msg_type === 'generate_answer_finish') {
          // 这种类型通常表示生成完成，但没有具体内容
          return null;
        }
        
        // 处理 empty result 类型
        if (parsed.msg_type === 'empty result') {
          return '抱歉，我无法回答这个问题。';
        }
        
        return null;
      } catch (e) {
        return null;
      }
    }

    parseMessageContent(content) {
      try {
        const parsed = JSON.parse(content);
        
        // 处理不同的消息类型
        if (parsed.msg_type === 'stream_plugin_finish' && parsed.data) {
          const dataParsed = JSON.parse(parsed.data);
          if (dataParsed.tool_output_content) {
            return dataParsed.tool_output_content;
          }
        }
        
        if (parsed.msg_type === 'generate_answer_finish') {
          // 这种类型通常表示生成完成，但没有具体内容
          return null;
        }
        
        if (parsed.msg_type === 'empty result') {
          return '抱歉，我无法回答这个问题。';
        }
        
        return null;
      } catch (e) {
        return null;
      }
    }

    extractMessageFromResponse(data) {
      
      // 从流式响应中提取助手的消息
      if (data.content) {
        return data.content;
      }
      
      // 从非流式响应中提取消息
      if (data.messages && data.messages.length > 0) {
        const assistantMessages = data.messages.filter(msg => msg.role === 'assistant');
        if (assistantMessages.length > 0) {
          return assistantMessages[assistantMessages.length - 1].content;
        }
      }
      
      // 尝试其他可能的字段
      if (data.message?.content) {
        return data.message.content;
      }
      
      if (data.text) {
        return data.text;
      }
      
      console.error('无法提取消息内容');
      return '收到回复，但格式异常。';
    }

    addTempMessage(messageId) {
      const messageDiv = document.createElement('div');
      messageDiv.id = messageId;
      messageDiv.className = 'flex items-start space-x-2';
      
      messageDiv.innerHTML = `
        <div class="flex-shrink-0 w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center text-white">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
          </svg>
        </div>
        <div class="flex-1 bg-white dark:bg-gray-800 rounded-lg p-3 shadow-sm">
          <div class="text-sm text-gray-800 dark:text-gray-200">
            <div class="flex items-center space-x-2">
              <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-primary-500"></div>
              <span class="text-gray-500 dark:text-gray-400">AI 正在思考...</span>
            </div>
          </div>
        </div>
      `;
      
      this.messagesContainer.appendChild(messageDiv);
      this.scrollToBottom();
    }

    typewriterEffect(messageId, content) {
      const messageDiv = document.getElementById(messageId);
      if (!messageDiv) {
        console.log('未找到消息元素:', messageId);
        return;
      }
      
      console.log('开始打字机效果');
      
      // 清理内容，移除技术信息
      const cleanedContent = this.cleanContent(content);
      
      // 查找内容容器，可能是加载状态或正常内容
      let contentDiv = messageDiv.querySelector('.text-sm.text-gray-800');
      if (!contentDiv) {
        // 如果没有找到，可能是加载状态，需要替换整个内容区域
        const messageContainer = messageDiv.querySelector('.flex-1');
        if (messageContainer) {
          messageContainer.innerHTML = `
            <div class="text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap"></div>
          `;
          contentDiv = messageContainer.querySelector('.text-sm.text-gray-800');
        }
      }
      
      if (!contentDiv) return;
      
      // 开始打字机效果
      let index = 0;
      const speed = 30; // 每个字符的延迟（毫秒）
      
      const typeNext = () => {
        if (index < cleanedContent.length) {
          const currentText = cleanedContent.substring(0, index + 1);
          contentDiv.innerHTML = this.formatMessage(currentText);
          this.scrollToBottom();
          index++;
          setTimeout(typeNext, speed);
        } else {
          // 打字完成，检查是否有建议问题需要添加
          this.checkAndAddFollowUpQuestions(messageId, content);
        }
      };
      
      // 开始打字
      typeNext();
    }

    checkAndAddFollowUpQuestions(messageId, originalContent) {
      // 这个方法会在流式响应完成后被调用，用于添加建议问题
      // 暂时先不实现，因为建议问题是在流式响应过程中收集的
    }

    updateTempMessageContent(messageId, content) {
      const messageDiv = document.getElementById(messageId);
      if (!messageDiv) {
        console.log('未找到消息元素:', messageId);
        return;
      }
      
      console.log('更新消息内容');
      
      // 查找内容容器，可能是加载状态或正常内容
      let contentDiv = messageDiv.querySelector('.text-sm.text-gray-800');
      if (!contentDiv) {
        // 如果没有找到，可能是加载状态，需要替换整个内容区域
        const messageContainer = messageDiv.querySelector('.flex-1');
        if (messageContainer) {
          console.log('替换整个内容区域');
          messageContainer.innerHTML = `
            <div class="text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${this.formatMessage(content)}</div>
          `;
          this.scrollToBottom();
        }
      } else {
        // 如果找到了内容区域，直接更新
        console.log('更新现有内容区域');
        contentDiv.innerHTML = this.formatMessage(content);
        this.scrollToBottom();
      }
    }

    updateTempMessage(messageId, content, role = 'assistant') {
      const messageDiv = document.getElementById(messageId);
      if (!messageDiv) return;
      
      if (role === 'error') {
        messageDiv.innerHTML = `
          <div class="flex-shrink-0 w-8 h-8 bg-red-500 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
          <div class="flex-1 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3">
            <p class="text-sm text-red-800 dark:text-red-200">${this.escapeHtml(content)}</p>
          </div>
        `;
      } else {
        messageDiv.innerHTML = `
          <div class="flex-shrink-0 w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
            </svg>
          </div>
          <div class="flex-1 bg-white dark:bg-gray-800 rounded-lg p-3 shadow-sm">
            <div class="text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${this.formatMessage(content)}</div>
          </div>
        `;
      }
      
      this.scrollToBottom();
      
      // 如果是助手消息且聊天窗口未打开，显示新消息提示
      if (role === 'assistant' && this.chatWindow.classList.contains('hidden')) {
        this.showNewMessageIndicator();
      }
    }

    addMessage(role, content) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'flex items-start space-x-2';
      
      if (role === 'user') {
        messageDiv.classList.add('flex-row-reverse', 'space-x-reverse');
        messageDiv.innerHTML = `
          <div class="flex-shrink-0 w-8 h-8 bg-gray-400 dark:bg-gray-600 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
            </svg>
          </div>
          <div class="flex-1 bg-primary-500 text-white rounded-lg p-3 shadow-sm">
            <p class="text-sm whitespace-pre-wrap">${this.escapeHtml(content)}</p>
          </div>
        `;
      } else if (role === 'assistant') {
        messageDiv.innerHTML = `
          <div class="flex-shrink-0 w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
            </svg>
          </div>
          <div class="flex-1 bg-white dark:bg-gray-800 rounded-lg p-3 shadow-sm">
            <div class="text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${this.formatMessage(content)}</div>
          </div>
        `;
      } else if (role === 'error') {
        messageDiv.innerHTML = `
          <div class="flex-shrink-0 w-8 h-8 bg-red-500 rounded-full flex items-center justify-center text-white">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
          <div class="flex-1 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3">
            <p class="text-sm text-red-800 dark:text-red-200">${this.escapeHtml(content)}</p>
          </div>
        `;
      }
      
      this.messagesContainer.appendChild(messageDiv);
      
      // 滚动到底部
      this.scrollToBottom();
      
      // 如果是助手消息且聊天窗口未打开，显示新消息提示
      if (role === 'assistant' && this.chatWindow.classList.contains('hidden')) {
        this.showNewMessageIndicator();
      }
    }

    isTechnicalContent(content) {
      // 检查是否是技术信息
      if (typeof content !== 'string') return false;
      
      // 检查是否包含 JSON 格式的技术信息
      if (content.includes('{"name":') || 
          content.includes('"plugin_id":') ||
          content.includes('"msg_type":') ||
          content.includes('"uuid":') ||
          content.includes('"finish_reason":') ||
          content.includes('bolg_protagonisths_wf directly streaming reply')) {
        return true;
      }
      
      return false;
    }

    formatMessage(content) {
      // 清理内容，移除技术信息
      let cleanedContent = this.cleanContent(content);
      
      // 简单的 Markdown 格式化
      let formatted = this.escapeHtml(cleanedContent);
      
      // 处理粗体 **text**
      formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      
      // 处理换行
      formatted = formatted.replace(/\n/g, '<br>');
      
      return formatted;
    }

    cleanContent(content) {
      if (typeof content !== 'string') return content;
      
      // 移除 JSON 格式的技术信息
      let cleaned = content
        // 移除完整的 JSON 对象
        .replace(/\{[^}]*"name":"[^"]*"[^}]*\}/g, '')
        .replace(/\{[^}]*"plugin_id":[^}]*\}/g, '')
        .replace(/\{[^}]*"msg_type":"[^"]*"[^}]*\}/g, '')
        .replace(/\{[^}]*"uuid":"[^"]*"[^}]*\}/g, '')
        .replace(/\{[^}]*"finish_reason":[^}]*\}/g, '')
        // 移除技术提示信息
        .replace(/bolg_protagonisths_wf directly streaming reply\./g, '')
        // 清理多余的空格和换行
        .replace(/\s+/g, ' ')
        .trim();
      
      return cleaned;
    }

    scrollToBottom() {
      setTimeout(() => {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      }, 100);
    }


    setInputEnabled(enabled) {
      this.messageInput.disabled = !enabled;
      this.sendBtn.disabled = !enabled;
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  }

  // 页面加载完成后初始化
  document.addEventListener('DOMContentLoaded', () => {
    window.cozeChatClient = new CozeChatClient();
  });
</script>

<style>
  /* 自定义滚动条 */
  #messages-container::-webkit-scrollbar {
    width: 6px;
  }

  #messages-container::-webkit-scrollbar-track {
    background: transparent;
  }

  #messages-container::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
  }

  #messages-container::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.3);
  }

  /* 深色模式滚动条 */
  .dark #messages-container::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
  }

  .dark #messages-container::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }

  /* 浮动小球动画 */
  #coze-chat-bubble {
    animation: float 3s ease-in-out infinite;
  }

  @keyframes float {
    0%, 100% {
      transform: translateY(0px);
    }
    50% {
      transform: translateY(-10px);
    }
  }

  /* 聊天窗口弹出动画 */
  #coze-chat-window {
    transform: scale(0.8) translateY(20px);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  #coze-chat-window:not(.hidden) {
    transform: scale(1) translateY(0);
    opacity: 1;
  }

  /* 新消息提示动画 */
  #new-message-indicator {
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.1);
    }
  }

  /* 响应式设计 */
  @media (max-width: 640px) {
    #coze-chat-container {
      bottom: 1rem;
      right: 1rem;
    }
    
    #coze-chat-window {
      width: calc(100vw - 2rem);
      height: calc(100vh - 2rem);
      max-height: calc(100vh - 2rem);
      right: -1rem;
    }
    
    #coze-chat-bubble {
      width: 3.5rem;
      height: 3.5rem;
    }
  }
</style>
